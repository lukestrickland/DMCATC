}
samples <- E1.block.B.V_cond.B.V.PMV.samples
load("data/samples/E1.block.B.V_cond.B.V.PMV.samples.RData")
for(i in 1:length(samples)) {
print(attr(samples[[i]], "auto"))
}
# Check your samples are all the same length for every participant
for(i in 1:length(samples)) {
print(samples[[i]]$nmc)
}
samples <- E1.block.B.V_cond.B.V.PMV.samples
for(i in 1:length(samples)) {
print(attr(samples[[i]], "auto"))
}
# Check your samples are all the same length for every participant
for(i in 1:length(samples)) {
print(samples[[i]]$nmc)
}
load("data/exp_data/okdats.E1.NR.RData")
names(okdats)[length(okdats)] <- "trial.pos"
levels(okdats$block)<- c("2", "3")
for (i in 1:length(samples)) {
data <- okdats[okdats$s==levels(okdats$s)[i],]
data <-data[,c(2,3,4,5,6,7)]
attr(samples[[i]], "NRdata") <- data
}
h.matched.samples <- h.post.predict.dmc.MATCHORDER(samples)
sim <- do.call(rbind, h.matched.samples)
getdata <- lapply(h.matched.samples, function(x) attr(x, "data"))
data <- do.call(rbind, getdata)
data<-add.trial.cumsum.data(data)
sim<-add.trial.cumsum.sim (sim, data)
NR.df <- get.NRs.ATCDMC(sim, data, miss_fun=get.trials.missed.E1_A4)
plot <- ggplot(NR.df, aes(cond, mean))
plot + geom_point(size=3) + geom_errorbar(aes(ymax = upper, ymin = lower), width= 0.2) +
geom_point(aes(cond, data), pch=21, size=4,
colour="black")+geom_line(aes(group = 1, y=data), linetype=2)+
ylab("Probability of non-response") + xlab("Time Pressure/ Traffic Load")
mark_sim_nrs <- sim$cond=="A" & sim$cumsum>12 |sim$cond=="B" & sim$cumsum>8 |
sim$cond=="C" & sim$cumsum>20 |sim$cond=="D" & sim$cumsum>10
sim.noNRs <- sim[!mark_sim_nrs,]
data.noNRs <- data[data$R!="M",]
# Desired level names for graphs of factors
# Rename appropriately
lev.S <- c("Conflict", "Nonconflict", "PM (Conflict)", "PM (Nonconflict)")
lev.PM <- c("Control", "PM")
lev.cond <- c("LL.LT", "LL.HT",
"HL.LT", "HL.HT")
# Conflict R, Nonconf R, PMR
lev.R <- c("CR", "NR", "PMR")
get.fitgglist.dmc()
get.fitgglist.dmc
levels(dats$S)
levels(data$S)
levels(data$R)
levels(data.noNR$R)
levels(data.noNRs$R)
data.noNRs$R <- factor(as.character(data.noNRs$R ))
levels(data.noNRs$R)
str(GGlist)
red level names for graphs of factors
# Rename appropriately
lev.S <- c("Conflict", "Nonconflict", "PM (Conflict)", "PM (Nonconflict)")
lev.PM <- c("Control", "PM")
lev.cond <- c("LL.LT", "LL.HT",
"HL.LT", "HL.HT")
# Conflict R, Nonconf R, PMR
lev.R <- c("CR", "NR", "PMR")
GGLIST <- get.fitgglist.dmc(sim, data)
str(sim)
str(data)
sim <- do.call(rbind, h.matched.samples)
getdata <- lapply(h.matched.samples, function(x) attr(x, "data"))
data <- do.call(rbind, getdata)
data<-add.trial.cumsum.data(data)
sim<-add.trial.cumsum.sim (sim, data)
head(sim)
add.trial.cumsum.sim
sim <- do.call(rbind, h.matched.samples)
getdata <- lapply(h.matched.samples, function(x) attr(x, "data"))
data <- do.call(rbind, getdata)
sim$trial <- rep(data$trial, max(sim$reps))
for(i in 1:max(sim$reps)) {
sim$trial[sim$reps==i] <- data$trial + (i-1)*max(data$trial)
}
data<-add.trial.cumsum.data(data)
sim$trial <- rep(data$trial, max(sim$reps))
for(i in 1:max(sim$reps)) {
sim$trial[sim$reps==i] <- data$trial + (i-1)*max(data$trial)
}
head(sim)
sim<-data.table(sim)
sim<-sim[,list(
reps,      cond ,     block,     S   ,
R   ,      RT ,       trial.pos,
trial ,
cumsum=cumsum(RT)),list(trial)]
head(sim)
sim<-sim[,list(
reps,      cond ,     block,     S   ,
R   ,      RT ,       trial.pos,
cumsum=cumsum(RT)),list(trial)]
data.frame(sim)
add.trial.cumsum.sim <- function (sim, data) {
if (!all.equal(rep(data$trial.pos, 100), sim$trial.pos)){
stop("Data and Sim Trial Positions do not match")
}
sim$trial <- rep(data$trial, max(sim$reps))
for(i in 1:max(sim$reps)) {
sim$trial[sim$reps==i] <- data$trial + (i-1)*max(data$trial)
}
sim<-data.table(sim)
sim<-sim[,list(
reps,      cond ,     block,     S   ,
R   ,      RT ,       trial.pos,
cumsum=cumsum(RT)),list(trial)]
data.frame(sim)
[,-1]
}
add.trial.cumsum.sim <- function (sim, data) {
if (!all.equal(rep(data$trial.pos, 100), sim$trial.pos)){
stop("Data and Sim Trial Positions do not match")
}
sim$trial <- rep(data$trial, max(sim$reps))
for(i in 1:max(sim$reps)) {
sim$trial[sim$reps==i] <- data$trial + (i-1)*max(data$trial)
}
sim<-data.table(sim)
sim<-sim[,list(
reps,      cond ,     block,     S   ,
R   ,      RT ,       trial.pos,
cumsum=cumsum(RT)),list(trial)]
data.frame(sim)
}
sim<-add.trial.cumsum.sim (sim, data)
head(sim)
c("trial", "trial.pos", "cumsum") %in% names(sim)
names(sim) %in% # Rename appropriately
lev.S <- c("Conflict", "Nonconflict", "PM (Conflict)", "PM (Nonconflict)")
lev.PM <- c("Control", "PM")
lev.cond <- c("LL.LT", "LL.HT",
"HL.LT", "HL.HT")
names(sim) %in% c("trial", "trial.pos", "cumsum")
#levels for df
lev.S <- c("Conflict", "Nonconflict", "PM (Conflict)", "PM (Nonconflict)")
lev.PM <- c("Control", "PM")
lev.cond <- c("LL.LT", "LL.HT",
"HL.LT", "HL.HT")
NR.df
levels(NR.df)$cond<- lev.cond
plot <- ggplot(NR.df, aes(cond, mean))
plot + geom_point(size=3) + geom_errorbar(aes(ymax = upper, ymin = lower), width= 0.2) +
geom_point(aes(cond, data), pch=21, size=4,
colour="black")+geom_line(aes(group = 1, y=data), linetype=2)+
ylab("Probability of non-response") + xlab("Time Pressure/ Traffic Load")
lev.cond <- c("LL.LT", "LL.HT",
"HL.LT", "HL.HT")
NR.df <- get.NRs.ATCDMC(sim, data, miss_fun=get.trials.missed.E1_A4)
levels(NR.df)$cond<- lev.cond
plot <- ggplot(NR.df, aes(cond, mean))
plot + geom_point(size=3) + geom_errorbar(aes(ymax = upper, ymin = lower), width= 0.2) +
geom_point(aes(cond, data), pch=21, size=4,
colour="black")+geom_line(aes(group = 1, y=data), linetype=2)+
ylab("Probability of non-response") + xlab("Time Pressure/ Traffic Load")
NR.df
lev.cond
levels(NR.df$cond)<- lev.cond
plot <- ggplot(NR.df, aes(cond, mean))
plot + geom_point(size=3) + geom_errorbar(aes(ymax = upper, ymin = lower), width= 0.2) +
geom_point(aes(cond, data), pch=21, size=4,
colour="black")+geom_line(aes(group = 1, y=data), linetype=2)+
ylab("Probability of non-response") + xlab("Time Pressure/ Traffic Load")
NR.df <- get.NRs.ATCDMC(sim, data, miss_fun=get.trials.missed.E1_A4)
levels(NR.df$cond)<- lev.cond
plot <- ggplot(NR.df, aes(cond, mean))
plot + geom_point(size=3) + geom_errorbar(aes(ymax = upper, ymin = lower), width= 0.2) +
geom_point(aes(cond, data), pch=21, size=4,
colour="black")+geom_line(aes(group = 1, y=data), linetype=2)+
ylab("Probability of non-response") + xlab("Time Pressure/ Traffic Load")
NR.df
mark_sim_nrs <- sim$cond=="A" & sim$cumsum>12 |sim$cond=="B" & sim$cumsum>8 |
sim$cond=="C" & sim$cumsum>20 |sim$cond=="D" & sim$cumsum>10
sim.noNRs <- sim[!mark_sim_nrs,]
data.noNRs <- data[data$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
head(sim.noNRs)
GGLIST <- get.fitgglist.dmc(sim.noNRs, datanoNRs)
GGLIST <- get.fitgglist.dmc(sim.noNRs, data.noNRs)
GGlist
GGLIST
ggplot.RP.dmc(GGLIST[[1]])
ggplot.RP.dmc(GGLIST[[1]], xaxis="cond")
ggplot.RT.dmc(GGLIST[[2]], xaxis="cond")
warnings()
check<- h.post.predict.dmc(E1.block.B.V_cond.B.V.PMV.samples)
ggplot.RT.dmc(check, xaxis="cond")
ggplot.RT.dmc(check, xaxis="cond")
ggplot.RT.dmc(GGLIST[[2]], xaxis="cond")
clean <- function(df) {
dfc <- df
n=tapply(df$RT,list(df$s),length)
ns=tapply(df$RT,list(df$s),length)
mn=tapply(df$RT,list(df$s),mean)
sd=tapply(df$RT,list(df$s),IQR)
upper <- mn+3*(sd/1.349)
lower <- 0.2
bad <- logical(dim(df)[1])
levs <- paste(df$s,sep=".")
for (i in levels(df$s)){
lev <- i
bad[levs==lev] <- df[levs==lev,"RT"] > upper[i] | df[levs==lev,"RT"] < lower
}
df=df[!bad,]
nok=tapply(df$RT,list(df$s),length)
pbad=100-100*nok/n
nok=tapply(df$RT,list(df$s),length)
pbad=100-100*nok/ns
print(sort(round(pbad,5)))
print(mean(pbad,na.rm=T))
df
}
data.noNRs <- clean(data.noNRs)
head(data)
length(data)
length(data$RT)
length(okdats$RT)
data.withs <- data
data.withs$s <- okdats$s
data.noNRs <- data[data$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <- clean(data.noNRs)
head(data.noNRs)
data.withs$s <- okdats$s
data.noNRs <- data.withs[data.withs$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <- clean(data.noNRs)
GGLIST <- get.fitgglist.dmc(sim.noNRs, data.noNRs)
ggplot.RT.dmc(GGLIST[[2]], xaxis="cond")
ggplot.RT.dmc(GGLIST[[2]], xaxis="cond")
sim.noNRs <- sim[!mark_sim_nrs,]
data.withs <- data
data.withs$s <- okdats$s
data.noNRs <- data.withs[data.withs$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <- clean(data.noNRs)
head(data.noNRs)
data.noNRs <- data.noNRs[,-length(data.noNRs)]
data.noNRs
#from
data.noNRs <- data.noNRs[,-length(data.noNRs)]
# Desired level names for graphs of factors
# Conflict R, Nonconf R, PMR
GGLIST <- get.fitgglist.dmc(sim.noNRs, data.noNRs)
head(data.noNRs)
#Take the non-responses out and take out the factors we needed only to calc them
sim.noNRs <- sim[!mark_sim_nrs,]
data.withs <- data
data.withs$s <- okdats$s
data.noNRs <- data.withs[data.withs$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <- clean(data.noNRs)
#We removed <0.2s from the data and >3 IQR as we did for the data we estimated
#from
data.noNRs <- data.noNRs[,-length(data.noNRs)]
# Desired level names for graphs of factors
# Conflict R, Nonconf R, PMR
GGLIST <- get.fitgglist.dmc(sim.noNRs, data.noNRs)
ggplot.RT.dmc(GGLIST[[2]], xaxis="cond")
warnings()
ggplot.RT.dmc(GGLIST[[2]], xaxis="cond")
ggplot.RT.dmc(check, xaxis="cond")
GGLIST[[2]]
get.hdata.dmc <- function(hsamples){
list.wind<-lapply(seq_along(hsamples), function(samples, n, i) cbind(n[[i]], samples[[i]]$data),
samples= hsamples, n = names(hsamples))
out<-do.call(rbind, list.wind)
names(out)[1] <- "s"
out
}
checkdata <- get.hdata.dmc(E1.block.B.V_cond.B.V.PMV.samples)
checkdata
head(checkdata)
head(data.noNRs)
all.equal(checkdata[,-1], data.noNRs)
head(checkdata[,i1])
head(checkdata[,-1])
head(data.noNRs)
length(checkdata$RT)
length(data$noNRs)
length(data.noNRs$RT)
is.na(data.noNRs$RT)
any(is.na(data.noNRs$RT))
data.withs <- data
data.withs$s <- okdats$s
data.noNRs <- data.withs[data.withs$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs
tail(data.noNRs)
the non-responses out and take out the factors we needed only to calc them
sim.noNRs <- sim[!mark_sim_nrs,]
data.withs <- data
data.withs$s <- okdats$s
data[(data$block=="2" & data$R=="P"),]
data[(data$block=="2" & data$R=="P"),]
head(dat)
head(data)
length(data.noNRs)
length(data.noNRs$RT)
data.withs <- data
data.withs$s <- okdats$s
data<-data[!(data$block=="2" & data$R=="P"),]
data.noNRs <- data.withs[data.withs$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
length(data.noNRs$RT)
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <- clean(data.noNRs)
str(data.noNRs)
lower
head(data.noNRs)
str(data.noNRs)
data.withs <- data
data.withs$s <- okdats$s
data<-data[!(data$block=="2" & data$R=="P"),]
data.noNRs <- data.withs[data.withs$R!="M",]
data.noNRs$R <- factor(as.character(data.noNRs$R ))
sim.noNRs <-
sim.noNRs[,!(names(sim.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
data.noNRs <-
data.noNRs[,!(names(data.noNRs) %in% c("trial", "trial.pos", "cumsum"))]
str(data.noNRs)
mean(data.noNRs$RT)
okdats <- data.noNRs[,c(6,1:5)]
head(okdats)
data.noNRs <- clean(okdats)
save(okdats, file="test.RData")
# Running this top to bottom should correspond to my data analysis from the
# PMDC manuscript.
rm(list=ls())
# setwd("~/russ_model_analyses")
setwd("D:/Software/DMC_ATCPMDC")
source("dmc/dmc.R")
source("dmc/dmc_ATC.R")
load("data/samples/E1.block.B.V_cond.B.V.PMV.samples.RData")
samples <- E1.block.B.V_cond.B.V.PMV.samples
setwd("~/Software/DMCATC")
h.ordermatched.sims <- h.post.predict.dmc.MATCHORDER(samples)
save(h.ordermatched.sims,
file="data/after_sampling/E1NRPP.RData")
h.ordermatched.sims <- h.post.predict.dmc.MATCHORDER(samples)
str(samples)
h.ordermatched.sims <- h.post.predict.dmc.MATCHORDER(samples)
post.predict.dmc.MATCHORDER <- function(samples,n.post=100,probs=c(1:99)/100,random=TRUE,
bw="nrd0",report=10,save.simulation=FALSE,factors=NA,
save.simulation.as.attribute=FALSE,ignore.R2=FALSE,
gglist=FALSE, probs.gglist=c(0.1, 0.5, 0.9),CI.gglist=c(0.025, 0.975))
# make list of posterior preditive density, quantiles and response p(robability)
# NB: quantiles only calcualted for 2 or more RTs
{
model <- attributes(samples$data)$model
facs <- names(attr(model,"factors"))
cvs <- samples$data[,attr(model,"cvs")]
attr(cvs,"row.facs") <- apply(apply(
samples$data[,facs,drop=FALSE],2,as.character),1,paste,collapse=".")
if ( ignore.R2 & any(names(samples$data)=="R2") )
samples$data <- samples$data[,names(samples$data)[names(samples$data)!="R2"]]
if (!is.null(factors) ) {
if (any(is.na(factors))) factors <- facs
if (!all(factors %in% facs))
stop(paste("Factors argument must contain one or more of:",paste(facs,collapse=",")))
}
resp <- names(attr(model,"responses"))
##LUKE: plug in data size from okdats.noNR
data <- attr(samples, "NRdata")
ns <- table(data[,facs])
# ns <- table(samples$data[,facs],dnn=facs)
n.par <- dim(samples$theta)[2]
thetas <- matrix(aperm(samples$theta,c(3,1,2)),ncol=n.par)
colnames(thetas) <- dimnames(samples$theta)[[2]]
if (is.na(n.post)) use <- c(1:dim(thetas)[1]) else {
if (random) use <- sample(c(1:dim(thetas)[1]),n.post,replace=F) else
use <- round(seq(1,dim(thetas)[1],length.out=n.post))
}
n.post <- length(use)
posts <- thetas[use,]
n.rep <- sum(ns)
sim <- data.frame(matrix(nrow=n.post*n.rep,ncol=dim(data)[2]))
names(sim) <- names(data)
# Tweaks for Stop Signal
if ( !any(names(samples$data)=="SSD") ) {
SSD <- rep(Inf,sum(ns))
leave.out <- -c(1:dim(samples$data)[2])[names(samples$data) %in% c("RT",names(cvs),"R2")]
} else {
# Assumes last two are SSD and RT! FIX ME. EG WONT WORK IF THERE ARE CVS
if (is.null(facs)) SSD <- samples$data$SSD else
SSD <- unlist(tapply(samples$data$SSD,samples$data[,facs],identity))
leave.out <- -c((dim(samples$data)[2]-1):dim(samples$data)[2])
}
cat("\n")
cat(paste("Simulating (\'.\'=",report,"): ",sep=""))
for (i in names(samples$data)[leave.out])
sim[[i]] <- factor(rep(NA,n.post*n.rep),levels=levels(samples$data[[i]]))
for (i in 1:n.post) {
tmp <- simulate.dmc(posts[i,],model,n=ns,SSD=SSD,cvs=NULL)
if ( (i %% report) == 0) cat(".")
###Luke plug in order matching
callargs.data <- list()
callargs.sim <- list()
for (p in 1:length(facs)) {callargs.data[[p]] <- data[,facs[p]]
callargs.sim[[p]] <- tmp[,facs[p]]
}
data.ind <- factor(do.call(paste, callargs.data))
sim.ind <- factor(do.call(paste, callargs.sim))
swappedsim <- data
for(q in levels(data.ind)){swappedsim$R[data.ind==q] <- tmp$R[sim.ind==q]
swappedsim$RT[data.ind==q] <- tmp$RT[sim.ind==q]
}
tmp <- swappedsim
if (ignore.R2) tmp <- tmp[,names(tmp)[names(tmp)!="R2"]]
sim[(1+(i-1)*n.rep):(i*n.rep),names(tmp)] <- tmp
########
}
if ( any(names(sim)=="R2") ) { # MTR model
sim$R <- paste(as.character(sim$R),as.character(sim$R2),sep="")
sim$R[sim$R2=="DK"] <- "DK"
sim$R <- factor(sim$R)
samples$data$R <- paste(as.character(samples$data$R),as.character(samples$data$R2),sep="")
samples$data$R[samples$data$R2=="DK"] <- "DK"
samples$data$R <- factor(samples$data$R)
}
reps <- rep(1:n.post,each=dim(data)[1])
if ( save.simulation ) {
sim <- cbind(reps,sim)
attr(sim,"data") <- data
# attr(sim,"data") <- samples$data
sim
} else {
sim.dqp <- get.dqp(sim,facs=factors,probs,n.post,ns=ns,bw=bw)
dat.dqp <- get.dqp(sim=samples$data,factors,probs,bw=bw)
names(dat.dqp) <- paste("data",names(dat.dqp),sep=".")
out <- c(sim.dqp,dat.dqp)
dpqs <- vector(mode="list",length=length(n.post))
for (i in 1:n.post) {
simi <- sim[reps==i,]
dpqs[[i]] <- get.dqp(simi,factors,probs,1)
}
attr(out,"dpqs") <- dpqs
if (save.simulation.as.attribute)
attr(out,"sim") <- cbind(reps,sim)
if (gglist) attr(out, "gglist") <-
get.fitgglist.dmc(cbind(reps,sim),samples$data,factors=factors, noR=FALSE,
quantiles.to.get= probs.gglist, CI = CI.gglist)
out
}
}
h.post.predict.dmc.MATCHORDER <- function(hsamples) {
lapply(hsamples, post.predict.dmc.MATCHORDER, save.simulation=TRUE)
}
h.ordermatched.sims <- h.post.predict.dmc.MATCHORDER(samples)
h.ordermatched.sims <- h.post.predict.dmc.MATCHORDER(samples)
Do out of sample predictions of non-responses to see whether they are
#consistent with the model.
load("data/exp_data/okdats.E1.NR.RData")
names(okdats)[length(okdats)] <- "trial.pos"
levels(okdats$block)<- c("2", "3")
for (i in 1:length(samples)) {
data <- okdats[okdats$s==levels(okdats$s)[i],]
data <-data[,c(2,3,4,5,6,7)]
attr(samples[[i]], "NRdata") <- data
}
h.ordermatched.sims <- h.post.predict.dmc.MATCHORDER(samples)
save(h.ordermatched.sims,
file="data/after_sampling/E1NRPP.RData")
NRsim <- do.call(rbind, h.ordermatched.sims)
getNRdata <- lapply(h.ordermatched.sims, function(x) attr(x, "data"))
NRdata <- do.call(rbind, getNRdata)
NRdata<-add.trial.cumsum.data(NRdata)
NRsim<-add.trial.cumsum.sim (NRsim, NRdata)
###
NR.df <- get.NRs.ATCDMC(NRsim, NRdata, miss_fun=get.trials.missed.E1_A4)
levels(NR.df$cond)<- lev.cond
plot <- ggplot(NR.df, aes(cond, mean))
plot + geom_point(size=3) + geom_errorbar(aes(ymax = upper, ymin = lower),
width= 0.2) +
geom_point(aes(cond, data), pch=21, size=4,
colour="black")+geom_line(aes(group = 1, y=data), linetype=2)+
ylab("Probability of non-response") + xlab("Time Pressure/ Traffic Load")
