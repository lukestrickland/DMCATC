if (all(is.na(out))) NULL else out
}
qs <- tapply(sim$RT,sim[,c(facs,"R")],quantile.names,probs=probs,na.rm=TRUE)
#     qs <- apply(qs,1:length(dim(qs)),function(x){
#       if ( is.null(x[[1]]) || all(is.na(x[[1]]))) NULL else x[[1]]})
# get probabilities given not na
simOK <- sim[!is.na(sim$RT),]
p <- tapply(simOK$RT,simOK[,c(facs,"R")],length)
p[is.na(p)] <- 0 # In case some cells are empty
np <- rep(apply(p,1:length(facs),sum),times=length(levels(simOK$R)))
p <- p/np
# get p NA
pNA <- tapply(sim$RT,sim[,c(facs,"R")],length)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
npNA <- rep(apply(pNA,1:length(facs),sum),times=length(levels(sim$R)))
pNA <- tapply(is.na(sim$RT),sim[,c(facs,"R")],sum)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
pNA <- pNA/npNA
# For a simulation get proability replicates
if (!is.na(n.post)) {
repfac <- rep(1:n.post,each=sum(ns))
repfac <- repfac[!is.na(sim$RT)]
ps <- tapply(simOK$RT,cbind(simOK[,c(facs,"R")],rep=repfac),length)
ps[is.na(ps)] <- 0 # In case some cells are empty
ps <- n.post*ps/np
# and NA replicates
pNAs <- tapply(is.na(sim$RT),cbind(sim[,c(facs,"R")],rep=rep(1:n.post,each=sum(ns))),sum)
pNAs[is.na(pNAs)] <- 0 # In case some cells are empty
pNAs <- n.post*pNAs/npNA
} else {
ps=NULL
pNAs=NULL
}
# cell names
cell.names <- dimnames(qs)[[1]]
n.cell <- length(facs)+1
for ( i in 2:n.cell )
cell.names <- outer(cell.names,dimnames(qs)[[i]],"paste",sep=".")
cell.names <- as.vector(cell.names)
# Get density and make defective
dens <- tapply(sim$RT,sim[,c(facs,"R")],function(x){
if (all(is.na(x))) NULL else {
x <- x[x>=quantile(x,.01,na.rm=TRUE) & x<=quantile(x,.99,na.rm=TRUE)]
if (length(x[!is.na(x)])<2) NULL else density(x[!is.na(x)],bw=bw)
}
})
for (i in 1:length(p)) if ( is.finite(p[i]) && !(p[i]==0) )
{
if (!is.null(qs[i][[1]])) {
names(qs[i][[1]]) <- as.numeric(names(qs[i][[1]]))*p[i]/100
attr(qs[i][[1]],"cell.name") <- cell.names[i]
}
if (!is.null(dens[i][[1]]) ) {
dens[i][[1]]$y <- dens[i][[1]]$y*p[i]
attr(dens[i][[1]],"cell.name") <- cell.names[i]
}
}
dnd <- dimnames(dens)
dnq <- dimnames(qs)
dens <- apply(dens,1:length(facs),function(x){x})
qs <- apply(qs,1:length(facs),function(x){x})
if ( is.null(dim(dens)) ) {
dens <- array(dens,dim=c(length(dens)))
dimnames(dens) <- dnd[-length(dnd)]
qs <- array(qs,dim=c(length(qs)))
dimnames(qs) <- dnq[-length(dnq)]
}
list(pdf=dens,cdf=qs,p=p,ps=ps,pNA=pNA,pNAs=pNAs)
}
model <- attributes(samples$data)$model
facs <- names(attr(model,"factors"))
if (any(is.na(factors))) factors <- facs
if (!all(factors %in% facs))
stop(paste("Factors argument must contain one or more of:",paste(facs,collapse=",")))
resp <- names(attr(model,"responses"))
ns <- table(samples$data[,facs],dnn=facs)
n.par <- dim(samples$theta)[2]
thetas <- matrix(aperm(samples$theta,c(3,1,2)),ncol=n.par)
colnames(thetas) <- dimnames(samples$theta)[[2]]
if (is.na(n.post)) use <- c(1:dim(thetas)[1]) else {
if (random) use <- sample(c(1:dim(thetas)[1]),n.post,replace=F) else
use <- round(seq(1,dim(thetas)[1],length.out=n.post))
}
n.post <- length(use)
posts <- thetas[use,]
###Replace some parameter vlaues with others.
posts[,colnames(posts) %in% pickps_others] <- posts[,colnames(posts) %in% pickps_set]
########
n.rep <- sum(ns)
sim <- data.frame(matrix(nrow=n.post*n.rep,ncol=dim(samples$data)[2]))
names(sim) <- names(samples$data)
# Tweaks for Stop Signal
if ( !any(names(samples$data)=="SSD") ) {
SSD <- rep(Inf,sum(ns))
leave.out <- -c(1:dim(samples$data)[2])[names(samples$data)=="RT"]
} else {
# Assumes last two are SSD and RT! FIX ME.
if (is.null(facs)) SSD <- samples$data$SSD else
SSD <- unlist(tapply(samples$data$SSD,samples$data[,facs],identity))
leave.out <- -c((dim(samples$data)[2]-1):dim(samples$data)[2])
}
cat("\n")
cat(paste("Simulating (\'.\'=",report,"): ",sep=""))
for (i in names(samples$data)[leave.out])
sim[[i]] <- factor(rep(NA,n.post*n.rep),levels=levels(samples$data[[i]]))
for (i in 1:n.post) {
tmp <- simulate.dmc(posts[i,],model,ns,SSD=SSD)
sim[(1+(i-1)*n.rep):(i*n.rep),names(tmp)] <- tmp
if ( (i %% report) == 0) cat(".")
}
if ( any(names(sim)=="R2") ) { # MTR model
sim$R <- paste(as.character(sim$R),as.character(sim$R2),sep="")
sim$R[sim$R2=="DK"] <- "DK"
sim$R <- factor(sim$R)
samples$data$R <- paste(as.character(samples$data$R),as.character(samples$data$R2),sep="")
samples$data$R[samples$data$R2=="DK"] <- "DK"
samples$data$R <- factor(samples$data$R)
}
if (save.simulation) {
sim <- cbind(reps=rep(1:n.post,each=dim(samples$data)[1]),sim)
attr(sim,"data") <- samples$data
sim
} else {
sim.dqp <- get.dqp(sim,factors,probs,n.post)
dat.dqp <- get.dqp(sim=samples$data,factors,probs)
names(dat.dqp) <- paste("data",names(dat.dqp),sep=".")
c(sim.dqp,dat.dqp)
}
}
get.dqp <- function(sim,facs,probs,n.post=NA) {
quantile.names <- function(x,probs=seq(0, 1, 0.25),na.rm=FALSE,type=7, ...) {
out <- quantile(x,probs=probs,na.rm=na.rm,type=type,names=FALSE,...)
names(out) <- probs*100
if (all(is.na(out))) NULL else out
}
qs <- tapply(sim$RT,sim[,c(facs,"R")],quantile.names,probs=probs,na.rm=TRUE)
#     qs <- apply(qs,1:length(dim(qs)),function(x){
#       if ( is.null(x[[1]]) || all(is.na(x[[1]]))) NULL else x[[1]]})
# get probabilities given not na
simOK <- sim[!is.na(sim$RT),]
p <- tapply(simOK$RT,simOK[,c(facs,"R")],length)
p[is.na(p)] <- 0 # In case some cells are empty
np <- rep(apply(p,1:length(facs),sum),times=length(levels(simOK$R)))
p <- p/np
# get p NA
pNA <- tapply(sim$RT,sim[,c(facs,"R")],length)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
npNA <- rep(apply(pNA,1:length(facs),sum),times=length(levels(sim$R)))
pNA <- tapply(is.na(sim$RT),sim[,c(facs,"R")],sum)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
pNA <- pNA/npNA
# For a simulation get proability replicates
if (!is.na(n.post)) {
repfac <- rep(1:n.post,each=sum(ns))
repfac <- repfac[!is.na(sim$RT)]
ps <- tapply(simOK$RT,cbind(simOK[,c(facs,"R")],rep=repfac),length)
ps[is.na(ps)] <- 0 # In case some cells are empty
ps <- n.post*ps/np
# and NA replicates
pNAs <- tapply(is.na(sim$RT),cbind(sim[,c(facs,"R")],rep=rep(1:n.post,each=sum(ns))),sum)
pNAs[is.na(pNAs)] <- 0 # In case some cells are empty
pNAs <- n.post*pNAs/npNA
} else {
ps=NULL
pNAs=NULL
}
# cell names
cell.names <- dimnames(qs)[[1]]
n.cell <- length(facs)+1
for ( i in 2:n.cell )
cell.names <- outer(cell.names,dimnames(qs)[[i]],"paste",sep=".")
cell.names <- as.vector(cell.names)
# Get density and make defective
dens <- tapply(sim$RT,sim[,c(facs,"R")],function(x){
if (all(is.na(x))) NULL else {
x <- x[x>=quantile(x,.01,na.rm=TRUE) & x<=quantile(x,.99,na.rm=TRUE)]
if (length(x[!is.na(x)])<2) NULL else density(x[!is.na(x)],bw=bw)
}
})
for (i in 1:length(p)) if ( is.finite(p[i]) && !(p[i]==0) )
{
if (!is.null(qs[i][[1]])) {
names(qs[i][[1]]) <- as.numeric(names(qs[i][[1]]))*p[i]/100
attr(qs[i][[1]],"cell.name") <- cell.names[i]
}
if (!is.null(dens[i][[1]]) ) {
dens[i][[1]]$y <- dens[i][[1]]$y*p[i]
attr(dens[i][[1]],"cell.name") <- cell.names[i]
}
}
dnd <- dimnames(dens)
dnq <- dimnames(qs)
dens <- apply(dens,1:length(facs),function(x){x})
qs <- apply(qs,1:length(facs),function(x){x})
if ( is.null(dim(dens)) ) {
dens <- array(dens,dim=c(length(dens)))
dimnames(dens) <- dnd[-length(dnd)]
qs <- array(qs,dim=c(length(qs)))
dimnames(qs) <- dnq[-length(dnq)]
}
list(pdf=dens,cdf=qs,p=p,ps=ps,pNA=pNA,pNAs=pNAs)
}
model <- attributes(samples$data)$model
facs <- names(attr(model,"factors"))
if (any(is.na(factors))) factors <- facs
if (!all(factors %in% facs))
stop(paste("Factors argument must contain one or more of:",paste(facs,collapse=",")))
resp <- names(attr(model,"responses"))
ns <- table(samples$data[,facs],dnn=facs)
n.par <- dim(samples$theta)[2]
thetas <- matrix(aperm(samples$theta,c(3,1,2)),ncol=n.par)
colnames(thetas) <- dimnames(samples$theta)[[2]]
if (is.na(n.post)) use <- c(1:dim(thetas)[1]) else {
if (random) use <- sample(c(1:dim(thetas)[1]),n.post,replace=F) else
use <- round(seq(1,dim(thetas)[1],length.out=n.post))
}
n.post <- length(use)
posts <- thetas[use,]
pickps.post.predict.dmc = function(samples,n.post=100,probs=c(1:99)/100,random=TRUE,
bw="nrd0",report=10,save.simulation=TRUE,factors=NA, pickps_others, pickps_set)
# make list of posterior preditive density, quantiles and response p(robability)
{
get.dqp <- function(sim,facs,probs,n.post=NA) {
quantile.names <- function(x,probs=seq(0, 1, 0.25),na.rm=FALSE,type=7, ...) {
out <- quantile(x,probs=probs,na.rm=na.rm,type=type,names=FALSE,...)
names(out) <- probs*100
if (all(is.na(out))) NULL else out
}
qs <- tapply(sim$RT,sim[,c(facs,"R")],quantile.names,probs=probs,na.rm=TRUE)
#     qs <- apply(qs,1:length(dim(qs)),function(x){
#       if ( is.null(x[[1]]) || all(is.na(x[[1]]))) NULL else x[[1]]})
# get probabilities given not na
simOK <- sim[!is.na(sim$RT),]
p <- tapply(simOK$RT,simOK[,c(facs,"R")],length)
p[is.na(p)] <- 0 # In case some cells are empty
np <- rep(apply(p,1:length(facs),sum),times=length(levels(simOK$R)))
p <- p/np
# get p NA
pNA <- tapply(sim$RT,sim[,c(facs,"R")],length)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
npNA <- rep(apply(pNA,1:length(facs),sum),times=length(levels(sim$R)))
pNA <- tapply(is.na(sim$RT),sim[,c(facs,"R")],sum)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
pNA <- pNA/npNA
# For a simulation get proability replicates
if (!is.na(n.post)) {
repfac <- rep(1:n.post,each=sum(ns))
repfac <- repfac[!is.na(sim$RT)]
ps <- tapply(simOK$RT,cbind(simOK[,c(facs,"R")],rep=repfac),length)
ps[is.na(ps)] <- 0 # In case some cells are empty
ps <- n.post*ps/np
# and NA replicates
pNAs <- tapply(is.na(sim$RT),cbind(sim[,c(facs,"R")],rep=rep(1:n.post,each=sum(ns))),sum)
pNAs[is.na(pNAs)] <- 0 # In case some cells are empty
pNAs <- n.post*pNAs/npNA
} else {
ps=NULL
pNAs=NULL
}
# cell names
cell.names <- dimnames(qs)[[1]]
n.cell <- length(facs)+1
for ( i in 2:n.cell )
cell.names <- outer(cell.names,dimnames(qs)[[i]],"paste",sep=".")
cell.names <- as.vector(cell.names)
# Get density and make defective
dens <- tapply(sim$RT,sim[,c(facs,"R")],function(x){
if (all(is.na(x))) NULL else {
x <- x[x>=quantile(x,.01,na.rm=TRUE) & x<=quantile(x,.99,na.rm=TRUE)]
if (length(x[!is.na(x)])<2) NULL else density(x[!is.na(x)],bw=bw)
}
})
for (i in 1:length(p)) if ( is.finite(p[i]) && !(p[i]==0) )
{
if (!is.null(qs[i][[1]])) {
names(qs[i][[1]]) <- as.numeric(names(qs[i][[1]]))*p[i]/100
attr(qs[i][[1]],"cell.name") <- cell.names[i]
}
if (!is.null(dens[i][[1]]) ) {
dens[i][[1]]$y <- dens[i][[1]]$y*p[i]
attr(dens[i][[1]],"cell.name") <- cell.names[i]
}
}
dnd <- dimnames(dens)
dnq <- dimnames(qs)
dens <- apply(dens,1:length(facs),function(x){x})
qs <- apply(qs,1:length(facs),function(x){x})
if ( is.null(dim(dens)) ) {
dens <- array(dens,dim=c(length(dens)))
dimnames(dens) <- dnd[-length(dnd)]
qs <- array(qs,dim=c(length(qs)))
dimnames(qs) <- dnq[-length(dnq)]
}
list(pdf=dens,cdf=qs,p=p,ps=ps,pNA=pNA,pNAs=pNAs)
}
model <- attributes(samples$data)$model
facs <- names(attr(model,"factors"))
if (any(is.na(factors))) factors <- facs
if (!all(factors %in% facs))
stop(paste("Factors argument must contain one or more of:",paste(facs,collapse=",")))
resp <- names(attr(model,"responses"))
ns <- table(samples$data[,facs],dnn=facs)
n.par <- dim(samples$theta)[2]
thetas <- matrix(aperm(samples$theta,c(3,1,2)),ncol=n.par)
colnames(thetas) <- dimnames(samples$theta)[[2]]
if (is.na(n.post)) use <- c(1:dim(thetas)[1]) else {
if (random) use <- sample(c(1:dim(thetas)[1]),n.post,replace=F) else
use <- round(seq(1,dim(thetas)[1],length.out=n.post))
}
n.post <- length(use)
posts <- thetas[use,]
###Replace some parameter vlaues with others.
posts[,colnames(posts) %in% pickps_others] <- posts[,colnames(posts) %in% pickps_set]
########
n.rep <- sum(ns)
sim <- data.frame(matrix(nrow=n.post*n.rep,ncol=dim(samples$data)[2]))
names(sim) <- names(samples$data)
# Tweaks for Stop Signal
if ( !any(names(samples$data)=="SSD") ) {
SSD <- rep(Inf,sum(ns))
leave.out <- -c(1:dim(samples$data)[2])[names(samples$data)=="RT"]
} else {
# Assumes last two are SSD and RT! FIX ME.
if (is.null(facs)) SSD <- samples$data$SSD else
SSD <- unlist(tapply(samples$data$SSD,samples$data[,facs],identity))
leave.out <- -c((dim(samples$data)[2]-1):dim(samples$data)[2])
}
cat("\n")
cat(paste("Simulating (\'.\'=",report,"): ",sep=""))
for (i in names(samples$data)[leave.out])
sim[[i]] <- factor(rep(NA,n.post*n.rep),levels=levels(samples$data[[i]]))
for (i in 1:n.post) {
tmp <- simulate.dmc(posts[i,],model,ns,SSD=SSD)
sim[(1+(i-1)*n.rep):(i*n.rep),names(tmp)] <- tmp
if ( (i %% report) == 0) cat(".")
}
if ( any(names(sim)=="R2") ) { # MTR model
sim$R <- paste(as.character(sim$R),as.character(sim$R2),sep="")
sim$R[sim$R2=="DK"] <- "DK"
sim$R <- factor(sim$R)
samples$data$R <- paste(as.character(samples$data$R),as.character(samples$data$R2),sep="")
samples$data$R[samples$data$R2=="DK"] <- "DK"
samples$data$R <- factor(samples$data$R)
}
if (save.simulation) {
sim <- cbind(reps=rep(1:n.post,each=dim(samples$data)[1]),sim)
attr(sim,"data") <- samples$data
sim
} else {
sim.dqp <- get.dqp(sim,factors,probs,n.post)
dat.dqp <- get.dqp(sim=samples$data,factors,probs)
names(dat.dqp) <- paste("data",names(dat.dqp),sep=".")
c(sim.dqp,dat.dqp)
}
}
pickps.post.predict.dmc = function(samples,n.post=100,probs=c(1:99)/100,random=TRUE,
bw="nrd0",report=10,save.simulation=TRUE,factors=NA, pickps_others, pickps_set)
# make list of posterior preditive density, quantiles and response p(robability)
{
get.dqp <- function(sim,facs,probs,n.post=NA) {
quantile.names <- function(x,probs=seq(0, 1, 0.25),na.rm=FALSE,type=7, ...) {
out <- quantile(x,probs=probs,na.rm=na.rm,type=type,names=FALSE,...)
names(out) <- probs*100
if (all(is.na(out))) NULL else out
}
qs <- tapply(sim$RT,sim[,c(facs,"R")],quantile.names,probs=probs,na.rm=TRUE)
#     qs <- apply(qs,1:length(dim(qs)),function(x){
#       if ( is.null(x[[1]]) || all(is.na(x[[1]]))) NULL else x[[1]]})
# get probabilities given not na
simOK <- sim[!is.na(sim$RT),]
p <- tapply(simOK$RT,simOK[,c(facs,"R")],length)
p[is.na(p)] <- 0 # In case some cells are empty
np <- rep(apply(p,1:length(facs),sum),times=length(levels(simOK$R)))
p <- p/np
# get p NA
pNA <- tapply(sim$RT,sim[,c(facs,"R")],length)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
npNA <- rep(apply(pNA,1:length(facs),sum),times=length(levels(sim$R)))
pNA <- tapply(is.na(sim$RT),sim[,c(facs,"R")],sum)
pNA[is.na(pNA)] <- 0 # In case some cells are empty
pNA <- pNA/npNA
# For a simulation get proability replicates
if (!is.na(n.post)) {
repfac <- rep(1:n.post,each=sum(ns))
repfac <- repfac[!is.na(sim$RT)]
ps <- tapply(simOK$RT,cbind(simOK[,c(facs,"R")],rep=repfac),length)
ps[is.na(ps)] <- 0 # In case some cells are empty
ps <- n.post*ps/np
# and NA replicates
pNAs <- tapply(is.na(sim$RT),cbind(sim[,c(facs,"R")],rep=rep(1:n.post,each=sum(ns))),sum)
pNAs[is.na(pNAs)] <- 0 # In case some cells are empty
pNAs <- n.post*pNAs/npNA
} else {
ps=NULL
pNAs=NULL
}
# cell names
cell.names <- dimnames(qs)[[1]]
n.cell <- length(facs)+1
for ( i in 2:n.cell )
cell.names <- outer(cell.names,dimnames(qs)[[i]],"paste",sep=".")
cell.names <- as.vector(cell.names)
# Get density and make defective
dens <- tapply(sim$RT,sim[,c(facs,"R")],function(x){
if (all(is.na(x))) NULL else {
x <- x[x>=quantile(x,.01,na.rm=TRUE) & x<=quantile(x,.99,na.rm=TRUE)]
if (length(x[!is.na(x)])<2) NULL else density(x[!is.na(x)],bw=bw)
}
})
for (i in 1:length(p)) if ( is.finite(p[i]) && !(p[i]==0) )
{
if (!is.null(qs[i][[1]])) {
names(qs[i][[1]]) <- as.numeric(names(qs[i][[1]]))*p[i]/100
attr(qs[i][[1]],"cell.name") <- cell.names[i]
}
if (!is.null(dens[i][[1]]) ) {
dens[i][[1]]$y <- dens[i][[1]]$y*p[i]
attr(dens[i][[1]],"cell.name") <- cell.names[i]
}
}
dnd <- dimnames(dens)
dnq <- dimnames(qs)
dens <- apply(dens,1:length(facs),function(x){x})
qs <- apply(qs,1:length(facs),function(x){x})
if ( is.null(dim(dens)) ) {
dens <- array(dens,dim=c(length(dens)))
dimnames(dens) <- dnd[-length(dnd)]
qs <- array(qs,dim=c(length(qs)))
dimnames(qs) <- dnq[-length(dnq)]
}
list(pdf=dens,cdf=qs,p=p,ps=ps,pNA=pNA,pNAs=pNAs)
}
model <- attributes(samples$data)$model
facs <- names(attr(model,"factors"))
if (any(is.na(factors))) factors <- facs
if (!all(factors %in% facs))
stop(paste("Factors argument must contain one or more of:",paste(facs,collapse=",")))
resp <- names(attr(model,"responses"))
ns <- table(samples$data[,facs],dnn=facs)
n.par <- dim(samples$theta)[2]
thetas <- matrix(aperm(samples$theta,c(3,1,2)),ncol=n.par)
colnames(thetas) <- dimnames(samples$theta)[[2]]
if (is.na(n.post)) use <- c(1:dim(thetas)[1]) else {
if (random) use <- sample(c(1:dim(thetas)[1]),n.post,replace=F) else
use <- round(seq(1,dim(thetas)[1],length.out=n.post))
}
n.post <- length(use)
posts <- thetas[use,]
###Replace some parameter vlaues with others.
posts[,colnames(posts) %in% pickps_others] <- posts[,colnames(posts) %in% pickps_set]
########
n.rep <- sum(ns)
sim <- data.frame(matrix(nrow=n.post*n.rep,ncol=dim(samples$data)[2]))
names(sim) <- names(samples$data)
# Tweaks for Stop Signal
if ( !any(names(samples$data)=="SSD") ) {
SSD <- rep(Inf,sum(ns))
leave.out <- -c(1:dim(samples$data)[2])[names(samples$data)=="RT"]
} else {
# Assumes last two are SSD and RT! FIX ME.
if (is.null(facs)) SSD <- samples$data$SSD else
SSD <- unlist(tapply(samples$data$SSD,samples$data[,facs],identity))
leave.out <- -c((dim(samples$data)[2]-1):dim(samples$data)[2])
}
cat("\n")
cat(paste("Simulating (\'.\'=",report,"): ",sep=""))
for (i in names(samples$data)[leave.out])
sim[[i]] <- factor(rep(NA,n.post*n.rep),levels=levels(samples$data[[i]]))
for (i in 1:n.post) {
tmp <- simulate.dmc(posts[i,],model,ns,SSD=SSD)
sim[(1+(i-1)*n.rep):(i*n.rep),names(tmp)] <- tmp
if ( (i %% report) == 0) cat(".")
}
if ( any(names(sim)=="R2") ) { # MTR model
sim$R <- paste(as.character(sim$R),as.character(sim$R2),sep="")
sim$R[sim$R2=="DK"] <- "DK"
sim$R <- factor(sim$R)
samples$data$R <- paste(as.character(samples$data$R),as.character(samples$data$R2),sep="")
samples$data$R[samples$data$R2=="DK"] <- "DK"
samples$data$R <- factor(samples$data$R)
}
if (save.simulation) {
sim <- cbind(reps=rep(1:n.post,each=dim(samples$data)[1]),sim)
attr(sim,"data") <- samples$data
sim
} else {
sim.dqp <- get.dqp(sim,factors,probs,n.post)
dat.dqp <- get.dqp(sim=samples$data,factors,probs)
names(dat.dqp) <- paste("data",names(dat.dqp),sep=".")
c(sim.dqp,dat.dqp)
}
}
pickps.h.post.predict.dmc<- function(samples,n.post=100,probs=c(1:99)/100,
bw="nrd0",
save.simulation=FALSE, pickps_set, pickps_others)
# apply lost.predict to each subject
{
lapply(samples,pickps.post.predict.dmc,n.post=n.post,probs=probs,bw=bw,
save.simulation=save.simulation, pickps_set=pickps_set, pickps_others=pickps_others)
}
pickps.h.post.predict.dmc()
pickps.h.post.predict.dmc
pickps.h.post.predict.dmc(E1.block.B.V_cond.B.V.PMV.samples, pickps_others=pickps_other.
pickps_set=pickps_set)
pickps.h.post.predict.dmc(E1.block.B.V_cond.B.V.PMV.samples, pickps_others=pickps_other,
pickps_set=pickps_set)
control_thres_all <- pickps.h.post.predict.dmc(E1.block.B.V_cond.B.V.PMV.samples, pickps_others=pickps_other,
pickps_set=pickps_set)
control_thres_all
control_thres_all <- pickps.h.post.predict.dmc(E1.block.B.V_cond.B.V.PMV.samples, pickps_others=pickps_other,
pickps_set=pickps_set, save.simulation=T)
control_thres_all
